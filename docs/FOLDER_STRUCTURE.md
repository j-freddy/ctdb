# Folder Structure
*Author: fractal161*

A word on scope: this is written with someone completely new to development in mind. Everything will contain a description and (hopefully) a link to more comprehensive information.

Currently, the project's folder structure looks like this:

```
📁 docs
 ├── SETUP_QUICK.md
 └── ...
📁 prisma
 ├── 📁 migrations
 │    ├── migration_lock.toml
 │    ├── 📁 20220211020354_init
 │    └── ...
 ├── schema.prisma
 └── seed.ts
📁 src
 ├── 📁 elo/util
 │    ├── index.ts
 │    └── index.ts
 ├── 📁 graphql_schema
 │    ├── index.ts
 │    ├── enums.graphql
 │    ├── inputs.graphql
 │    ├── mutation.graphql
 │    ├── query.graphql
 │    └── types.graphql
 ├── 📁 mutation
 │    ├── index.ts
 │    ├── createMatchByEventId.ts
 │    └── ...
 ├── 📁 query
 │    ├── index.ts
 │    ├── getMatchesByPlayer.ts
 │    └── ...
 ├── 📁 resolvers
 │    ├── index.ts
 │    ├── Match.ts
 │    └── ...
 ├── 📁 types
 │    └── index.ts
 ├── index.ts
 ├── context.ts
 └── schema.ts
.env.example
.eslintrc.json
.gitignore
LICENSE
README.md
package-lock.json
package.json
tsconfig.json
```

It's definitely a lot to take in! I intend for this document to be used more as a reference, something you look at when you want answers for a specific file. With that being said, let's begin.

## Top Level

Mostly consists of setup and configuration code you'll see in several projects. Probably not necessary for understanding how CTDB "works" as a whole, but is definitely useful if you're interested in how to set up such a project yourself.

### .env.example

`.env` files, or "environment" files, are used to configure its application by containing one or more *environment variables*. In contrast to the other config files you'll see, these variables configure the code itself, rather than the tools to build it.

A simple example is a *debug* variable. When trying to track down an error, it's handy to have your code produce additional output that helps track exactly what's happening at any time. However, this can be annoying when you don't need help and can also slow things down. By storing what you want in a DEBUG environment variable, you can easily toggle this behavior.

A more advanced use case is customizing how you want the code to behave on your local computer versus the official product. For example, you'll typically want to test out new changes on personal test data rather than the official production data. Thus, you may want an environment variable to point to the dataset you're currently using.

Since these files may contain secret information (e.g. passwords), we provide `.env.example` as a template for you to substitute your own variables in. This is then copied into a `.env` file that only exists on your computer and is *never committed* (the consequences of sharing passwords or secrets go without saying).

[Here's](https://www.prisma.io/docs/guides/development-environment/environment-variables/managing-env-files-and-setting-variables) an overview of some of the environment variables Prisma uses.

### .eslintrc.json

Contains configuration options for [ESLint](https://eslint.org/), a tool that assists JavaScript/TypeScript development by auto-formatting code and identifying possible errors. The `rc` at the end stands for "run commands," and is a common suffix for config files (e.g a [.bashrc](https://www.digitalocean.com/community/tutorials/bashrc-file-in-linux) to customize your terminal experience).

In addition to the obvious benefits, ESLint lets developers enforce a specific code style (e.g. tabs vs spaces, how to position braces) even with multiple contributors.

[Here's](https://eslint.org/docs/latest/user-guide/configuring/) a list of some configuration options that ESLint supports.

### .gitignore

Contains a list of files that you don't want to be tracked by [git](https://en.wikipedia.org/wiki/Git).

We've already covered one very important example: the `.env` file. Including this in your `.gitignore` makes it less likely you accidently publish your secrets by accident.

Another use is to ignore things generated by your code, which could include caches (frequently accessed data) or performance logs. Basically anything that isn't absolutely required to set things up properly should be ignored.

Since the number of files you want to ignore could get quite large, you're able to specify *patterns* that identify groups of files to ignore. For example, `*.log` tells git to ignore any file that ends in `.log`.

You can find a collection of generic `.gitignore` files [here](https://github.com/github/gitignore), or you can check out its official documentation [here](https://git-scm.com/docs/gitignore).

### LICENSE

Contains guidelines for what use is allowed with this code. Developers may specify a number of permissions, like whether commercial products can use it or whether it can be modified.

Common license types are the permissive [MIT License](https://opensource.org/licenses/MIT), or the [GPLv3](https://www.gnu.org/licenses/gpl-3.0.en.html), which ensures your software remains free to access in any case.

CTDB uses the Affero GPLv3, which is [slightly modified](https://www.gnu.org/licenses/why-affero-gpl.en.html) from the traditional GPL. You can find a comparison of many different licenses [here](https://choosealicense.com/).

### README.md

Acts as a starting point for the project. Typically explains its purpose and score, as well as how to set it up.

### package.json/package-lock.json

The `package.json` file contains packages installed through [npm](https://www.npmjs.com/) used in the program, as well as other meta-information about the project. Here are some examples of fields:

- `scripts` contains commands to be run for the project. For example, running `npm start` executes `ts-node src/index.ts`, which starts the entire project.
- `dependencies` is what contains the packages needed when running the program (in this case, a web server).
- `devDependencies` contains other libraries that aren't necessarily needed for production. For example, `@faker-js/faker` is used to create testing data. It may seem like `prisma` belongs in `dependencies` instead, but we put it here since it's viewed as a separate service.

*You do not need to ever look at the* `package-lock.json` *file*. It's autogenerated in cases like when a new package is installed or removed. It's committed to provide a history of what packages have been used throughout the development timeline, but odds are you just care about its current state, so the `package.json` file suffices.

### tsconfig.json

Configures [TypeScript](https://www.typescriptlang.org/), the enhancement to Javascript used throughout the project.

## docs

You're already here! These are just text files to explain how CTDB works, nothing more.

## prisma

This directory contains the code that controls the [Prisma database](https://www.prisma.io/).

### migrations

So I imagine this entire folder looks terrifying. The good thing is that you probably don't need to ever read it!

Just like how the `package-lock.json` keeps a history of the packages used throughout the project, the migrations keep a history of the *database structure*. Migrations are also what let us enhance the database structure without needing to re-enter the data all over.

Of course, the database will likely have been finished for some time, so all you need to do is look at the `schema.primsa` file to see its current structure.

The `migration-lock.toml` file contains the current database provider (we use `postgresql` but `mysql` and `sqlite` are other options). This is tracked if it's ever switched during development.

All of the other folders contain raw SQL (think of it as a lower level language that Prisma automatically genereates) that perform the actions we want. The names begin with a timestamp of when the migration occurred, followed by a brief description.

[Here's](https://www.prisma.io/docs/concepts/components/prisma-migrate) an overview of how it interacts with your data.

### schema.prisma

The *schema* is what contains our current database configuration, from its structure to how to set it up. It's written with the [Prisma Schema Language](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference), which is designed to be readable with minimal bloat. Let's take a look at how our schema is structured.

Its first entry identifies the `datasource`, which is the specific database we're using. In practice, we don't need to interact with it, as it's Prisma's job to take our commands and translate them into lower-level database queries.

The next entry is the `generator`, which determines how Prisma parses database queries. `prisma-client-js` is its default, but there are also several [community-made generators](https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators) available.

The remainder of the file contains the *data models*, which specifies exactly what's included in the database. Prisma organizes data into *objects* (the "O" in ORM). Here's what the `event` model looks like:

```javascript
model Event {
	id            String @id @default(cuid())
	name          String @db.VarChar(256) @unique
	edition       String? @db.VarChar(256)
	organizer     Organization? @relation(fields: [organizerId], references: [id])

	organizerId   String?
	start         DateTime?
	end           DateTime?

	matches       Match[]
}
```

Each row defines a *field* that belongs to the object. It starts with the field's name (self explanatory), followed by the data type used to represent it. We see most fields are stored as plain text (as `String`s), but we can use more appropriate data types in certain cases (e.g. we could use a string to store the `start` and `end` times of the event, but it's more appropriate to use the `DateTime` data type), or we can even use other models defined in the schema (as with `organizer` and `matches`).

You'll notice some rows contain a `?` next to the data type. This specifies the field is *optional*.

The additional parameters beginning with `@` symbols are *attributes*, used to specify additional information about the field. Let's look at the attributes next to `name`. `@unique` specifies that we don't want different events to have the same name, and `@db.VarChar(256)` says this name can be at most 256 characters long. You can check out different data types and attributes [here](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference).

For an summary of why the database is structured in exactly this way, check out the `ARCHITECTURE.md` documents (to be added haha).

### seed.ts

Contains code that's used to quickly create a database of fake test data.

## src

Coming soon!
